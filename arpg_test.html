<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Symmetry ‚Äî ARPG</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{background:#000;overflow:hidden;height:100vh;height:100dvh;touch-action:none;-webkit-user-select:none;user-select:none;overscroll-behavior:none;position:fixed;width:100%;font-family:'Segoe UI',sans-serif;color:#fff}
canvas{display:block}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
// ============================================================
// SYMMETRY ‚Äî Vampire Survivors-style Auto-battler ARPG
// Single HTML file, Canvas2D, no dependencies
// ============================================================
'use strict';

const C = document.getElementById('c');
const ctx = C.getContext('2d');
let W, H;
function resize(){W=C.width=innerWidth;H=C.height=innerHeight;}
resize(); addEventListener('resize',resize);

// Prevent touch defaults
document.addEventListener('touchstart',e=>{e.preventDefault()},{passive:false});
document.addEventListener('touchmove',e=>{e.preventDefault()},{passive:false});

const IS_TOUCH = 'ontouchstart' in window || navigator.maxTouchPoints>0;
const PI = Math.PI, TAU = PI*2;
const rnd=(a,b)=>a+Math.random()*(b-a);
const rndInt=(a,b)=>Math.floor(rnd(a,b+1));
const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
const ang=(a,b)=>Math.atan2(b.y-a.y,b.x-a.x);
const lerp=(a,b,t)=>a+(b-a)*t;
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

// ============================================================
// DATA ‚Äî Classes, Skills, Passives
// ============================================================
const CLASSES = {
  gunner: {
    name: 'Í±∞ÎÑà', nameEn:'Gunner', color:'#4fc3f7', icon:'üî´',
    desc: 'Ï¥ùÍ∏∞ Ï†ÑÎ¨∏Í∞Ä. ÏõêÍ±∞Î¶¨ ÎîúÎü¨Î°ú Îã§ÏñëÌïú ÏÇ¨Í≤© Ïä§ÌÇ¨ Î≥¥Ïú†.',
    baseHP:80, baseATK:12, baseDEF:3, baseSpd:3,
    skills: [
      {id:'shotgun',name:'ÏÉ∑Í±¥',desc:'Í∑ºÍ±∞Î¶¨ ÏõêÎøîÌòï Ìè≠Î∞ú, Í≥†Îç∞ÎØ∏ÏßÄ',cd:2,color:'#ff9800',type:'cone',dmgMul:2.5,range:120,angle:PI/3},
      {id:'machinegun',name:'Í∏∞Í¥ÄÏ¥ù',desc:'ÏßÅÏÑ† Ïó∞ÏÇ¨ ÌÉÑÌôò',cd:0.3,color:'#ffeb3b',type:'rapid',dmgMul:0.6,range:300},
      {id:'grenade',name:'ÏàòÎ•òÌÉÑ',desc:'Ìà¨Ï≤ô ÌõÑ Ìè≠Î∞ú, Í¥ëÏó≠ Îç∞ÎØ∏ÏßÄ',cd:4,color:'#f44336',type:'grenade',dmgMul:3,range:250,radius:80},
      {id:'stimpack',name:'Ïä§ÌåÄÌå©',desc:'ÏùºÏãúÏ†Å Í≥µÍ≤©ÏÜçÎèÑ Ï¶ùÍ∞Ä',cd:8,color:'#76ff03',type:'buff',duration:4},
      {id:'russianroulette',name:'Îü¨ÏãúÏïàÎ£∞Î†õ',desc:'HP 30% Ïù¥ÌïòÏùº Îïå ÎßâÎåÄÌïú Îç∞ÎØ∏ÏßÄ',cd:5,color:'#e91e63',type:'conditional',dmgMul:5,range:200},
      {id:'napalm',name:'ÎÑ§Ïù¥ÌåúÌÉÑ',desc:'ÏßÄÎ©¥ ÌôîÏóº ÏßÄÎåÄ, ÏßÄÏÜç Îç∞ÎØ∏ÏßÄ',cd:6,color:'#ff5722',type:'zone',dmgMul:1,range:200,radius:90,duration:4},
      {id:'piercing',name:'Í¥ÄÌÜµÌÉÑ',desc:'Ï†Å Í¥ÄÌÜµ ÏßÅÏÑ† ÏÇ¨Í≤©',cd:3,color:'#00bcd4',type:'pierce',dmgMul:2,range:400},
      {id:'shotgunstorm',name:'ÏÇ∞ÌÉÑÌè≠Ìíç',desc:'360ÎèÑ Ï†ÑÎ∞©ÏúÑ ÏÇ∞ÌÉÑ',cd:5,color:'#ff6f00',type:'radial',dmgMul:1.5,range:150,count:12},
      {id:'drone',name:'ÎìúÎ°†Ìè¨Í≤©',desc:'ÎìúÎ°† ÏÜåÌôò, 8Ï¥àÍ∞Ñ ÏûêÎèô ÏÇ¨Í≤©',cd:12,color:'#80deea',type:'summon',duration:8,dmgMul:0.8},
      {id:'snipe',name:'Ï†ÄÍ≤©',desc:'Ïû•Í±∞Î¶¨ Îã®Ïùº ÎåÄÏÉÅ, Ï¥àÍ≥†Îç∞ÎØ∏ÏßÄ',cd:10,color:'#b71c1c',type:'snipe',dmgMul:8,range:500},
    ],
    passives: [
      {id:'gcrit',name:'ÏπòÎ™ÖÌÉÄ ÌôïÎ•† Ï¶ùÍ∞Ä',desc:'ÏπòÎ™ÖÌÉÄ ÌôïÎ•† +15%',effect:'critUp'},
      {id:'greload',name:'Ïû¨Ïû•Ï†Ñ ÏÜçÎèÑ Ï¶ùÍ∞Ä',desc:'Ïä§ÌÇ¨ Ïø®Îã§Ïö¥ -20%',effect:'cdDown'},
      {id:'gdouble',name:'50% ÎëêÎ∞ú ÏãúÏ†Ñ',desc:'50% ÌôïÎ•†Î°ú Ïä§ÌÇ¨ 2Ìöå ÏãúÏ†Ñ',effect:'doubleCast'},
      {id:'gexplosive',name:'Ìè≠Î∞úÎ¨º Ï†ÑÎ¨∏Í∞Ä',desc:'Í¥ëÏó≠ Ïä§ÌÇ¨ Î≤îÏúÑ +30%',effect:'aoeUp'},
      {id:'gweakness',name:'ÏïΩÏ†ê Ìè¨Ï∞©',desc:'HP 30% Ïù¥Ìïò Ï†ÅÏóêÍ≤å +50% Îç∞ÎØ∏ÏßÄ',effect:'execute30'},
      {id:'gbullets',name:'ÌÉÑÌôò ÏÑ∏Î°Ä',desc:'5Î≤àÏß∏ Í≥µÍ≤©ÎßàÎã§ Ï∂îÍ∞Ä ÌÉÑÌôò 3Î∞ú',effect:'extraBullets'},
    ]
  },
  mage: {
    name: 'ÎßàÎ≤ïÏÇ¨', nameEn:'Mage', color:'#ce93d8', icon:'üîÆ',
    desc: 'ÏõêÏÜå ÎßàÎ≤ï ÏÇ¨Ïö©Ïûê. Í∞ïÎ†•Ìïú Í¥ëÏó≠ ÎßàÎ≤ïÍ≥º Ï†úÏñ¥Í∏∞ Î≥¥Ïú†.',
    baseHP:60, baseATK:15, baseDEF:2, baseSpd:2.8,
    skills: [
      {id:'fireball',name:'ÌååÏù¥Ïñ¥Î≥º',desc:'ÌôîÏóºÍµ¨ Ìà¨ÏÇ¨Ï≤¥, Ï†ÅÏ§ë Ïãú Ìè≠Î∞ú',cd:2,color:'#ff5722',type:'projectile',dmgMul:2,range:300,radius:40,element:'fire'},
      {id:'icenova',name:'ÏïÑÏù¥Ïä§ÎÖ∏Î∞î',desc:'Ï£ºÎ≥Ä Í¥ëÏó≠ ÎπôÍ≤∞',cd:5,color:'#4fc3f7',type:'nova',dmgMul:1.5,radius:120,element:'ice',freeze:2},
      {id:'wavepart',name:'ÏûÖÏûêÏôÄ ÌååÎèô',desc:'50/50: Îã®Ïùº Îπî ÎòêÎäî Í¥ëÏó≠ ÌååÎèô',cd:3,color:'#e040fb',type:'wavepart',dmgMul:2.5,range:300,element:'arcane'},
      {id:'blaze',name:'Î∏îÎ†àÏù¥Ï¶à',desc:'Ïù¥Îèô Ïãú ÌôîÏóº ÏûêÏ∑® ÏÉùÏÑ±',cd:6,color:'#ff9800',type:'trail',duration:5,dmgMul:0.5,element:'fire'},
      {id:'gravity',name:'ÏÇ¨Í±¥Ïùò ÏßÄÌèâÏÑ†',desc:'Ï§ëÎ†•Ïû• ÏÜåÌôò, Ï†Å Ìù°Ïù∏',cd:8,color:'#7c4dff',type:'gravity',range:200,radius:100,duration:3,dmgMul:1,element:'arcane'},
      {id:'iceshield',name:'ÏñºÏùåÎ∞©Ìå®',desc:'5Ï¥à Î¨¥Ï†Å Î∞©Ìå®',cd:15,color:'#80deea',type:'shield',duration:5,element:'ice'},
      {id:'chainlightning',name:'Ï≤¥Ïù∏ÎùºÏù¥Ìä∏Îãù',desc:'Î≤àÍ∞úÍ∞Ä 5Î™ÖÏùò Ï†Å ÏÇ¨Ïù¥ Ïó∞ÏáÑ',cd:4,color:'#ffff00',type:'chain',dmgMul:1.8,bounces:5,element:'lightning'},
      {id:'meteor',name:'Î©îÌÖåÏò§',desc:'1.5Ï¥à ÌõÑ Í±∞ÎåÄ Ïö¥ÏÑù ÎÇôÌïò',cd:10,color:'#ff3d00',type:'meteor',dmgMul:6,radius:120,delay:1.5,element:'fire'},
      {id:'teleport',name:'ÌÖîÎ†àÌè¨Ìä∏',desc:'ÏàúÍ∞ÑÏù¥Îèô, ÎèÑÏ∞©ÏßÄ Îç∞ÎØ∏ÏßÄ',cd:6,color:'#b388ff',type:'teleport',dmgMul:2,radius:60,element:'arcane'},
      {id:'manaexplosion',name:'ÎßàÎÇòÌè≠Î∞ú',desc:'HP 30% Ìù¨ÏÉù, Ï¥àÍ∞ïÎ†• Í¥ëÏó≠',cd:8,color:'#ea80fc',type:'manaexplosion',dmgMul:5,radius:150,element:'arcane'},
    ],
    passives: [
      {id:'micearrow',name:'ÏñºÏùåÌôîÏÇ¥',desc:'ÎπôÍ≤∞ Ï†ÅÏóêÍ≤å Î≥¥ÎÑàÏä§ ÏñºÏùå ÌôîÏÇ¥',effect:'iceArrow'},
      {id:'mtimewarp',name:'ÏãúÍ≥µÍ∞Ñ ÏôúÍ≥°',desc:'Ïø®Îã§Ïö¥ 50% Í∞êÏÜå',effect:'cdHalf'},
      {id:'mashtoash',name:'Ïû¨ÏóêÏÑú Ïû¨Î°ú',desc:'Î∂àÌÉÄÎäî Ï†ÅÏóêÍ≤å +30% Îç∞ÎØ∏ÏßÄ',effect:'burnDmg'},
      {id:'mmanaflow',name:'ÎßàÎÇòÏùò ÌùêÎ¶Ñ',desc:'Ï†Å Ï≤òÏπò ÌõÑ 3Ï¥àÍ∞Ñ ÏûêÏõê Î¨¥ÏÜåÎ™®',effect:'freecast'},
      {id:'mresonance',name:'ÏõêÏÜå Í≥µÎ™Ö',desc:'2Í∞ÄÏßÄ ÏõêÏÜå Ï†ÅÏ§ë Ïãú Ï∂îÍ∞Ä Ìè≠Î∞ú',effect:'eleResonance'},
      {id:'mchain',name:'Ïó∞ÏáÑÎ∞òÏùë',desc:'Í¥ëÏó≠ Ï≤òÏπò Ïãú 30% Ï∂îÍ∞Ä Ìè≠Î∞ú',effect:'chainExplosion'},
    ]
  },
  warrior: {
    name: 'Ï†ÑÏÇ¨', nameEn:'Warrior', color:'#ef5350', icon:'‚öîÔ∏è',
    desc: 'Í∑ºÏ†ë Ï†ÑÌà¨Ïùò Îã¨Ïù∏. ÎÜíÏùÄ Ï≤¥Î†•Í≥º Í∞ïÎ†•Ìïú Í∑ºÏ†ë Ïä§ÌÇ¨.',
    baseHP:120, baseATK:10, baseDEF:6, baseSpd:2.5,
    skills: [
      {id:'swordwave',name:'Í≤ÄÍ∏∞',desc:'Í≤ÄÍ∏∞ Ìà¨ÏÇ¨Ï≤¥ Î∞úÏÇ¨',cd:2,color:'#42a5f5',type:'projectile',dmgMul:2,range:250},
      {id:'bladecopy',name:'ÏπºÎÇ† Î≥µÏ†ú',desc:'Î∂ÑÏã† Í≤Ä ÏÜåÌôò, Ìï®Íªò Í≥µÍ≤©',cd:8,color:'#78909c',type:'summon',duration:6,dmgMul:0.7},
      {id:'whirlwind',name:'Ìú†ÏúàÎìú',desc:'ÌöåÏ†Ñ Í≥µÍ≤©, Ï£ºÎ≥Ä Ï†Å ÌÉÄÍ≤©',cd:4,color:'#66bb6a',type:'nova',dmgMul:1.8,radius:100},
      {id:'orbitblade',name:'ÌöåÏ†ÑÏπºÎÇ†',desc:'ÌîåÎ†àÏù¥Ïñ¥ Ï£ºÏúÑ Í≥µÏ†ÑÌïòÎäî ÏπºÎÇ†',cd:7,color:'#b0bec5',type:'orbit',duration:6,dmgMul:0.6,count:4},
      {id:'stomp',name:'Ïä§ÌÜ∞ÌîÑ',desc:'ÏßÄÎ©¥ Í∞ïÌÉÄ, Ï£ºÎ≥Ä Ï†Å Ïä§ÌÑ¥',cd:5,color:'#8d6e63',type:'nova',dmgMul:1.5,radius:90,stun:2},
      {id:'charge',name:'ÎèåÏßÑ',desc:'Ï†ÑÎ∞© ÎèåÏßÑ, Í≤ΩÎ°ú Ï†Å ÎÑâÎ∞±',cd:5,color:'#ffa726',type:'charge',dmgMul:2.5,range:200},
      {id:'block',name:'Î∞©Ìå®Ïò¨Î¶¨Í∏∞',desc:'3Ï¥à Î¨¥Ï†Å, Ïù¥ÌõÑ Î∞òÍ≤©',cd:10,color:'#90a4ae',type:'shield',duration:3},
      {id:'earthquake',name:'ÏßÄÏßÑ',desc:'ÏßÅÏÑ† Í∑†Ïó¥, Í≤ΩÎ°ú Îç∞ÎØ∏ÏßÄ',cd:6,color:'#795548',type:'line',dmgMul:3,range:300,width:40},
      {id:'warcry',name:'Ï†ÑÌà¨Ïùò Ìï®ÏÑ±',desc:'8Ï¥àÍ∞Ñ Í≥µÍ≤©Î†• +30%',cd:12,color:'#ffd54f',type:'buff',duration:8,atkBuff:0.3},
      {id:'execute',name:'Ï≤òÌòï',desc:'HP 25% Ïù¥Ìïò Ï†Å Ï≤òÌòï, Ï¥àÍ≥†Îç∞ÎØ∏ÏßÄ',cd:6,color:'#d32f2f',type:'execute',dmgMul:6,range:80},
    ],
    passives: [
      {id:'wlifesteal',name:'ÌîºÌù°',desc:'Í≥µÍ≤© Ïãú Îç∞ÎØ∏ÏßÄÏùò 20% ÌöåÎ≥µ',effect:'lifesteal'},
      {id:'wthorns',name:'Í∞ÄÏãúÍ∞ëÏò∑',desc:'Î∞õÏùÄ Îç∞ÎØ∏ÏßÄ 100% Î∞òÏÇ¨',effect:'thorns'},
      {id:'whpup',name:'ÌîºÌÜµ Ï¶ùÍ∞Ä',desc:'ÏµúÎåÄ Ï≤¥Î†• +40%',effect:'hpUp'},
      {id:'wunyielding',name:'Î∂àÍµ¥Ïùò ÏùòÏßÄ',desc:'HP 20% Ïù¥Ìïò Ïãú Î∞©Ïñ¥Î†• +50%',effect:'lowDefUp'},
      {id:'wberserker',name:'Í¥ëÏ†ÑÏÇ¨Ïùò Î∂ÑÎÖ∏',desc:'HP ÎÇÆÏùÑÏàòÎ°ù Í≥µÍ≤©Î†• Ï¶ùÍ∞Ä (ÏµúÎåÄ +50%)',effect:'berserker'},
      {id:'wiron',name:'Ï≤†Î≤Ω',desc:'10Ìöå ÌîºÍ≤©ÎßàÎã§ Îã§Ïùå ÌîºÍ≤© ÏôÑÏ†Ñ Ï∞®Îã®',effect:'ironWall'},
    ]
  }
};

// Common level-up passives (vampire survivors style)
const COMMON_PASSIVES = [
  {name:'Ï≤¥Î†• ÌöåÎ≥µ',desc:'Ï¶âÏãú HP 20% ÌöåÎ≥µ',apply:p=>{p.hp=Math.min(p.maxHp,p.hp+p.maxHp*0.2)}},
  {name:'Í≥µÍ≤©Î†• Ï¶ùÍ∞Ä',desc:'Í≥µÍ≤©Î†• +5',apply:p=>{p.atk+=5}},
  {name:'Î∞©Ïñ¥Î†• Ï¶ùÍ∞Ä',desc:'Î∞©Ïñ¥Î†• +3',apply:p=>{p.def+=3}},
  {name:'Ïù¥ÎèôÏÜçÎèÑ Ï¶ùÍ∞Ä',desc:'Ïù¥ÎèôÏÜçÎèÑ +10%',apply:p=>{p.spd*=1.1}},
  {name:'ÏµúÎåÄÏ≤¥Î†• Ï¶ùÍ∞Ä',desc:'ÏµúÎåÄ Ï≤¥Î†• +15',apply:p=>{p.maxHp+=15;p.hp+=15}},
  {name:'ÏπòÎ™ÖÌÉÄ Ï¶ùÍ∞Ä',desc:'ÏπòÎ™ÖÌÉÄ ÌôïÎ•† +5%',apply:p=>{p.critChance=(p.critChance||0)+0.05}},
  {name:'Í≤ΩÌóòÏπò Î≥¥ÎÑàÏä§',desc:'Í≤ΩÌóòÏπò ÌöçÎìù +20%',apply:p=>{p.expMul=(p.expMul||1)*1.2}},
  {name:'ÏûêÏÑù',desc:'ÏïÑÏù¥ÌÖú ÌöçÎìù Î≤îÏúÑ +30%',apply:p=>{p.pickupRange=(p.pickupRange||60)*1.3}},
  {name:'Ïû¨ÏÉùÎ†•',desc:'Ï¥àÎãπ HP 1 ÌöåÎ≥µ',apply:p=>{p.regen=(p.regen||0)+1}},
  {name:'ÌñâÏö¥',desc:'ÏïÑÏù¥ÌÖú ÎìúÎûçÎ•† +15%',apply:p=>{p.luck=(p.luck||1)*1.15}},
];

// ============================================================
// GAME STATE
// ============================================================
let state = 'title'; // title, classSelect, loadout, game, levelup, floorclear, victory, gameover
let selectedClass = null;
let classData = null;
let equippedSkills = []; // indices into classData.skills
let equippedPassives = []; // indices into classData.passives
let player = null;
let monsters = [];
let projectiles = [];
let particles = [];
let drops = [];
let damageNumbers = [];
let skillEffects = []; // visual effects
let currentFloor = 1;
let totalFloors = 5;
let killCount = 0;
let totalKills = 0;
let monstersToKill = 0;
let bossSpawned = false;
let bossDefeated = false;
let autoMode = true;
let screenShake = {x:0,y:0,t:0};
let camera = {x:0,y:0};
let keys = {};
let levelUpChoices = [];

// Touch/joystick
let joystick = {active:false,sx:0,sy:0,cx:0,cy:0,dx:0,dy:0,id:null};
let touchSkills = [null,null,null];
let mobileAutoBtn = {x:0,y:0,r:25};

// Timers
let dt = 0, lastTime = 0;
let gameTime = 0;

// Map
const MAP_W = 2400, MAP_H = 2400;
let obstacles = [];

// Attack counter for passives
let attackCounter = 0;
let hitsTaken = 0;

// ============================================================
// INPUT
// ============================================================
addEventListener('keydown',e=>{keys[e.code]=true;
  if(e.code==='Space'&&state==='game'){autoMode=!autoMode;e.preventDefault();}
});
addEventListener('keyup',e=>{keys[e.code]=false;});

// Touch handling
C.addEventListener('touchstart',e=>{
  for(let t of e.changedTouches){
    const tx=t.clientX, ty=t.clientY;
    // Left half = joystick
    if(tx<W/2 && state==='game'){
      if(!joystick.active){
        joystick={active:true,sx:tx,sy:ty,cx:tx,cy:ty,dx:0,dy:0,id:t.identifier};
      }
    }
    // Check skill buttons
    if(state==='game'){
      for(let i=0;i<3;i++){
        const bx=W-70, by=H-180+i*60;
        if(Math.hypot(tx-bx,ty-by)<30){
          if(!autoMode) useSkill(i);
        }
      }
      // Auto toggle
      if(Math.hypot(tx-mobileAutoBtn.x,ty-mobileAutoBtn.y)<mobileAutoBtn.r){
        autoMode=!autoMode;
      }
    }
  }
},{passive:true});
C.addEventListener('touchmove',e=>{
  for(let t of e.changedTouches){
    if(joystick.active && t.identifier===joystick.id){
      joystick.cx=t.clientX;joystick.cy=t.clientY;
      let ddx=joystick.cx-joystick.sx, ddy=joystick.cy-joystick.sy;
      let len=Math.hypot(ddx,ddy);
      if(len>50){ddx=ddx/len*50;ddy=ddy/len*50;}
      joystick.dx=ddx/50;joystick.dy=ddy/50;
    }
  }
},{passive:true});
C.addEventListener('touchend',e=>{
  for(let t of e.changedTouches){
    if(joystick.active && t.identifier===joystick.id){
      joystick.active=false;joystick.dx=0;joystick.dy=0;
    }
  }
},{passive:true});

// Mouse click for UI
C.addEventListener('click',e=>{
  handleClick(e.clientX, e.clientY);
});
C.addEventListener('touchend',e=>{
  if(e.changedTouches.length>0){
    const t=e.changedTouches[0];
    handleClick(t.clientX,t.clientY);
  }
},{passive:true});

function handleClick(mx,my){
  if(state==='title'){
    state='classSelect';return;
  }
  if(state==='classSelect'){
    // Check class buttons
    const cw=200,ch=260,gap=30;
    const cls=['gunner','mage','warrior'];
    const totalW=cls.length*cw+(cls.length-1)*gap;
    const startX=W/2-totalW/2;
    for(let i=0;i<3;i++){
      const bx=startX+i*(cw+gap), by=H/2-ch/2+20;
      if(mx>=bx&&mx<=bx+cw&&my>=by&&my<=by+ch){
        selectedClass=cls[i];
        classData=CLASSES[selectedClass];
        equippedSkills=[0,1,2];
        equippedPassives=[0,1];
        state='loadout';
        return;
      }
    }
    return;
  }
  if(state==='loadout'){
    // Skill selection
    const skills=classData.skills;
    const passives=classData.passives;
    const sx=40, sy=120, sw=150, sh=50, sg=8;
    for(let i=0;i<10;i++){
      const bx=sx, by=sy+i*(sh+sg);
      if(mx>=bx&&mx<=bx+sw&&my>=by&&my<=by+sh){
        if(equippedSkills.includes(i)){
          equippedSkills=equippedSkills.filter(s=>s!==i);
        } else if(equippedSkills.length<3){
          equippedSkills.push(i);
        }
        return;
      }
    }
    // Passive selection
    const px=W/2+40, py=120, pw=150, ph=50, pg=8;
    for(let i=0;i<6;i++){
      const bx=px, by=py+i*(ph+pg);
      if(mx>=bx&&mx<=bx+pw&&my>=by&&my<=by+ph){
        if(equippedPassives.includes(i)){
          equippedPassives=equippedPassives.filter(s=>s!==i);
        } else if(equippedPassives.length<2){
          equippedPassives.push(i);
        }
        return;
      }
    }
    // Start button
    const sbx=W/2-80, sby=H-80, sbw=160, sbh=50;
    if(mx>=sbx&&mx<=sbx+sbw&&my>=sby&&my<=sby+sbh){
      if(equippedSkills.length===3 && equippedPassives.length===2){
        startGame();
      }
    }
    return;
  }
  if(state==='levelup'){
    const cw=220, ch=100, gap=20;
    const totalCW=levelUpChoices.length*cw+(levelUpChoices.length-1)*gap;
    const startX=W/2-totalCW/2;
    for(let i=0;i<levelUpChoices.length;i++){
      const bx=startX+i*(cw+gap), by=H/2-ch/2;
      if(mx>=bx&&mx<=bx+cw&&my>=by&&my<=by+ch){
        levelUpChoices[i].apply(player);
        state='game';
        return;
      }
    }
    return;
  }
  if(state==='floorclear'){
    currentFloor++;
    if(currentFloor>totalFloors){state='victory';return;}
    startFloor();
    state='game';
    return;
  }
  if(state==='victory'||state==='gameover'){
    state='title';
    return;
  }
}

// ============================================================
// GAME INIT
// ============================================================
function startGame(){
  const cd = classData;
  player = {
    x:MAP_W/2, y:MAP_H/2, r:16,
    hp:cd.baseHP, maxHp:cd.baseHP, atk:cd.baseATK, def:cd.baseDEF, spd:cd.baseSpd,
    level:1, exp:0, expToLevel:100,
    gold:0, kills:0,
    critChance:0.05, expMul:1, pickupRange:60, regen:0, luck:1,
    skillCooldowns:[0,0,0],
    facingAngle:0,
    invincible:0,
    atkBuff:0, atkBuffTimer:0,
    spdBuff:0, spdBuffTimer:0,
    blaze:false, blazeTimer:0,
    shieldTimer:0,
    hitsTaken:0,
    ironWallCharged:false,
  };
  // Apply passives that modify stats
  applyEquippedPassives();
  currentFloor=1;
  totalKills=0;
  killCount=0;
  startFloor();
  state='game';
}

function applyEquippedPassives(){
  for(let pi of equippedPassives){
    const p=classData.passives[pi];
    if(p.effect==='hpUp'){player.maxHp*=1.4;player.hp=player.maxHp;}
    if(p.effect==='critUp'){player.critChance+=0.15;}
    if(p.effect==='cdDown'){/* applied in getCooldown */}
    if(p.effect==='cdHalf'){/* applied in getCooldown */}
  }
}

function hasPassive(effectName){
  for(let pi of equippedPassives){
    if(classData.passives[pi].effect===effectName) return true;
  }
  return false;
}

function getCooldown(baseCd){
  let cd=baseCd;
  if(hasPassive('cdDown')) cd*=0.8;
  if(hasPassive('cdHalf')) cd*=0.5;
  return cd;
}

function startFloor(){
  monsters=[];
  projectiles=[];
  particles=[];
  drops=[];
  damageNumbers=[];
  skillEffects=[];
  bossSpawned=false;
  bossDefeated=false;
  killCount=0;
  obstacles=[];
  
  // Generate obstacles
  for(let i=0;i<20+currentFloor*5;i++){
    obstacles.push({
      x:rnd(100,MAP_W-100), y:rnd(100,MAP_H-100),
      w:rnd(30,80), h:rnd(30,80)
    });
  }
  
  // Spawn monsters
  const meleeCount = 8 + currentFloor*4;
  const rangedCount = 4 + currentFloor*3;
  monstersToKill = meleeCount + rangedCount;
  
  for(let i=0;i<meleeCount;i++) spawnMonster('melee');
  for(let i=0;i<rangedCount;i++) spawnMonster('ranged');
  
  player.x=MAP_W/2;player.y=MAP_H/2;
}

function spawnMonster(type,x,y){
  const floorMul = 1 + (currentFloor-1)*0.4;
  if(x===undefined){
    // Spawn away from player
    do{x=rnd(50,MAP_W-50);y=rnd(50,MAP_H-50);}
    while(dist({x,y},player||{x:MAP_W/2,y:MAP_H/2})<300);
  }
  let m;
  if(type==='melee'){
    m={x,y,r:14,type:'melee',hp:30*floorMul,maxHp:30*floorMul,atk:5*floorMul,spd:1.5,color:'#ef5350',
       attackCd:0,attackRange:30,aggroRange:300,knockback:0,frozen:0,stunned:0,burning:0,burnDmg:0};
  } else if(type==='ranged'){
    m={x,y,r:12,type:'ranged',hp:20*floorMul,maxHp:20*floorMul,atk:8*floorMul,spd:1.2,color:'#ab47bc',
       attackCd:0,attackRange:200,shootCd:0,aggroRange:350,knockback:0,frozen:0,stunned:0,burning:0,burnDmg:0};
  } else if(type==='boss'){
    m={x,y,r:30,type:'boss',hp:200*floorMul,maxHp:200*floorMul,atk:15*floorMul,spd:1.8,color:'#ff9800',
       attackCd:0,attackRange:50,shootCd:0,aggroRange:500,knockback:0,frozen:0,stunned:0,burning:0,burnDmg:0,
       patternCd:0,pattern:0};
  }
  monsters.push(m);
}

// ============================================================
// SKILLS EXECUTION
// ============================================================
function useSkill(slotIndex){
  if(slotIndex>=equippedSkills.length) return;
  if(player.skillCooldowns[slotIndex]>0) return;
  
  const skillIdx = equippedSkills[slotIndex];
  const skill = classData.skills[skillIdx];
  const cd = getCooldown(skill.cd);
  player.skillCooldowns[slotIndex]=cd;
  
  executeSkill(skill);
  
  // Double cast passive
  if(hasPassive('doubleCast') && Math.random()<0.5){
    setTimeout(()=>executeSkill(skill),200);
  }
  
  attackCounter++;
  // Extra bullets passive
  if(hasPassive('extraBullets') && attackCounter%5===0){
    for(let i=0;i<3;i++){
      const a=player.facingAngle+rnd(-0.3,0.3);
      spawnProjectile(player.x,player.y,a,player.atk*0.5,300,'#ffeb3b',true,6);
    }
  }
}

function executeSkill(skill){
  const px=player.x, py=player.y;
  const nearest = findNearest(px,py,monsters);
  const targetAngle = nearest ? ang(player,nearest) : player.facingAngle;
  player.facingAngle = targetAngle;
  
  const dmg = player.atk * skill.dmgMul * (1 + (player.atkBuff||0));
  const aoeRadius = skill.radius ? skill.radius * (hasPassive('aoeUp')?1.3:1) : 0;
  
  switch(skill.type){
    case 'cone': {
      // Cone blast
      const halfAngle = (skill.angle||PI/3)/2;
      addEffect('cone',px,py,targetAngle,skill.range,halfAngle,skill.color,0.3);
      for(let m of monsters){
        if(dist(player,m)<skill.range){
          let a = ang(player,m);
          let diff = Math.abs(angleDiff(targetAngle,a));
          if(diff<halfAngle) dealDamage(m,dmg,skill.element);
        }
      }
      shakeScreen(4);
      break;
    }
    case 'rapid': {
      spawnProjectile(px,py,targetAngle,dmg,skill.range,skill.color,true,5);
      break;
    }
    case 'grenade': {
      const tx=px+Math.cos(targetAngle)*skill.range;
      const ty=py+Math.sin(targetAngle)*skill.range;
      addEffect('grenade',px,py,tx,ty,aoeRadius||skill.radius,skill.color,0.8,dmg,skill.element);
      break;
    }
    case 'buff': {
      if(skill.id==='stimpack'){
        // Reduce all cooldowns temporarily
        player.spdBuff=0.5;player.spdBuffTimer=skill.duration;
        addEffect('buff',px,py,0,0,40,skill.color,0.5);
      } else if(skill.atkBuff){
        player.atkBuff=skill.atkBuff;player.atkBuffTimer=skill.duration;
        addEffect('buff',px,py,0,0,40,skill.color,0.5);
      }
      break;
    }
    case 'conditional': {
      if(player.hp/player.maxHp<=0.3){
        // Massive damage to nearest
        if(nearest && dist(player,nearest)<skill.range){
          dealDamage(nearest,dmg*2,skill.element);
          addEffect('explosion',nearest.x,nearest.y,0,0,60,skill.color,0.4);
          shakeScreen(8);
        }
      } else if(nearest && dist(player,nearest)<skill.range){
        dealDamage(nearest,dmg*0.5,skill.element);
      }
      break;
    }
    case 'zone': {
      const tx=px+Math.cos(targetAngle)*(skill.range*0.6);
      const ty=py+Math.sin(targetAngle)*(skill.range*0.6);
      addEffect('zone',tx,ty,0,0,aoeRadius||skill.radius,skill.color,skill.duration,skill.dmgMul*player.atk,skill.element);
      break;
    }
    case 'pierce': {
      spawnProjectile(px,py,targetAngle,dmg,skill.range,skill.color,true,7,true);
      break;
    }
    case 'radial': {
      const count=skill.count||12;
      for(let i=0;i<count;i++){
        const a=TAU*i/count;
        spawnProjectile(px,py,a,dmg,skill.range,skill.color,true,4);
      }
      shakeScreen(5);
      break;
    }
    case 'summon': {
      if(skill.id==='drone'){
        addEffect('drone',px,py-40,0,0,0,skill.color,skill.duration,skill.dmgMul*player.atk);
      } else if(skill.id==='bladecopy'){
        addEffect('bladecopy',px,py,0,0,0,skill.color,skill.duration,skill.dmgMul*player.atk);
      }
      break;
    }
    case 'snipe': {
      if(nearest){
        const a=ang(player,nearest);
        addEffect('snipeline',px,py,Math.cos(a)*skill.range+px,Math.sin(a)*skill.range+py,0,'#ff1744',0.3);
        // Hit all in line
        for(let m of monsters){
          const mx=m.x-px, my=m.y-py;
          const proj = (mx*Math.cos(a)+my*Math.sin(a));
          const perp = Math.abs(-mx*Math.sin(a)+my*Math.cos(a));
          if(proj>0 && proj<skill.range && perp<20){
            dealDamage(m,dmg);
          }
        }
        shakeScreen(10);
      }
      break;
    }
    case 'projectile': {
      const p = spawnProjectile(px,py,targetAngle,dmg,skill.range,skill.color,true,8,false,aoeRadius,skill.element);
      break;
    }
    case 'nova': {
      const r = aoeRadius || skill.radius;
      addEffect('nova',px,py,0,0,r,skill.color,0.4);
      for(let m of monsters){
        if(dist(player,m)<r){
          dealDamage(m,dmg,skill.element);
          if(skill.freeze) m.frozen=skill.freeze;
          if(skill.stun) m.stunned=skill.stun;
        }
      }
      shakeScreen(6);
      break;
    }
    case 'wavepart': {
      if(Math.random()<0.5){
        // Beam - single target
        if(nearest && dist(player,nearest)<skill.range){
          addEffect('beam',px,py,nearest.x,nearest.y,0,skill.color,0.3);
          dealDamage(nearest,dmg*1.5,skill.element);
        }
      } else {
        // Wave
        const a=targetAngle;
        for(let m of monsters){
          const mx=m.x-px, my=m.y-py;
          const proj=(mx*Math.cos(a)+my*Math.sin(a));
          const perp=Math.abs(-mx*Math.sin(a)+my*Math.cos(a));
          if(proj>0&&proj<skill.range&&perp<50){
            dealDamage(m,dmg,skill.element);
          }
        }
        addEffect('wave',px,py,targetAngle,0,skill.range,skill.color,0.4);
      }
      break;
    }
    case 'trail': {
      player.blaze=true;player.blazeTimer=skill.duration;
      break;
    }
    case 'gravity': {
      const tx=px+Math.cos(targetAngle)*(skill.range*0.5);
      const ty=py+Math.sin(targetAngle)*(skill.range*0.5);
      addEffect('gravity',tx,ty,0,0,aoeRadius||skill.radius,skill.color,skill.duration,dmg);
      break;
    }
    case 'shield': {
      player.invincible=skill.duration;
      player.shieldTimer=skill.duration;
      addEffect('shield',px,py,0,0,30,'#80deea',skill.duration);
      break;
    }
    case 'chain': {
      if(nearest){
        let targets=[nearest];
        let last=nearest;
        for(let b=0;b<(skill.bounces||5)-1;b++){
          let best=null, bestD=200;
          for(let m of monsters){
            if(!targets.includes(m)){
              const d=dist(last,m);
              if(d<bestD){bestD=d;best=m;}
            }
          }
          if(best){targets.push(best);last=best;}
          else break;
        }
        for(let i=0;i<targets.length;i++){
          dealDamage(targets[i],dmg*(1-i*0.1),skill.element);
          if(i>0) addEffect('lightning',targets[i-1].x,targets[i-1].y,targets[i].x,targets[i].y,0,skill.color,0.3);
        }
        addEffect('lightning',px,py,targets[0].x,targets[0].y,0,skill.color,0.3);
      }
      break;
    }
    case 'meteor': {
      const tx=nearest?nearest.x:px+Math.cos(targetAngle)*150;
      const ty=nearest?nearest.y:py+Math.sin(targetAngle)*150;
      addEffect('meteor',tx,ty,0,0,aoeRadius||skill.radius,skill.color,skill.delay||1.5,dmg,skill.element);
      break;
    }
    case 'teleport': {
      const td=150;
      const nx=px+Math.cos(targetAngle)*td;
      const ny=py+Math.sin(targetAngle)*td;
      player.x=clamp(nx,20,MAP_W-20);
      player.y=clamp(ny,20,MAP_H-20);
      addEffect('explosion',player.x,player.y,0,0,aoeRadius||skill.radius,'#b388ff',0.3);
      for(let m of monsters){
        if(dist(player,m)<(skill.radius||60)) dealDamage(m,dmg,skill.element);
      }
      break;
    }
    case 'manaexplosion': {
      const cost=player.maxHp*0.3;
      player.hp=Math.max(1,player.hp-cost);
      const r=aoeRadius||skill.radius;
      addEffect('nova',px,py,0,0,r,'#ea80fc',0.5);
      for(let m of monsters){
        if(dist(player,m)<r) dealDamage(m,dmg,skill.element);
      }
      shakeScreen(12);
      break;
    }
    case 'charge': {
      const td=skill.range;
      const nx=px+Math.cos(targetAngle)*td;
      const ny=py+Math.sin(targetAngle)*td;
      // Damage along path
      for(let m of monsters){
        const mx=m.x-px, my=m.y-py;
        const proj=(mx*Math.cos(targetAngle)+my*Math.sin(targetAngle));
        const perp=Math.abs(-mx*Math.sin(targetAngle)+my*Math.cos(targetAngle));
        if(proj>0&&proj<td&&perp<40){
          dealDamage(m,dmg);
          m.knockback=0.5;
          m.kbx=Math.cos(targetAngle)*8;m.kby=Math.sin(targetAngle)*8;
        }
      }
      player.x=clamp(nx,20,MAP_W-20);
      player.y=clamp(ny,20,MAP_H-20);
      addEffect('charge',px,py,player.x,player.y,20,skill.color,0.3);
      shakeScreen(6);
      break;
    }
    case 'line': {
      const a=targetAngle;
      addEffect('crack',px,py,a,0,skill.range,skill.color,0.5);
      for(let m of monsters){
        const mx=m.x-px, my=m.y-py;
        const proj=(mx*Math.cos(a)+my*Math.sin(a));
        const perp=Math.abs(-mx*Math.sin(a)+my*Math.cos(a));
        if(proj>0&&proj<skill.range&&perp<(skill.width||40)/2){
          dealDamage(m,dmg);
        }
      }
      shakeScreen(8);
      break;
    }
    case 'orbit': {
      addEffect('orbit',px,py,0,0,60,skill.color,skill.duration,skill.dmgMul*player.atk,null,skill.count||4);
      break;
    }
    case 'execute': {
      if(nearest && dist(player,nearest)<(skill.range||80)){
        const bonus = (nearest.hp/nearest.maxHp<=0.25)?3:1;
        dealDamage(nearest,dmg*bonus);
        addEffect('explosion',nearest.x,nearest.y,0,0,40,'#d32f2f',0.3);
        shakeScreen(8);
      }
      break;
    }
  }
}

function angleDiff(a,b){let d=b-a;while(d>PI)d-=TAU;while(d<-PI)d+=TAU;return d;}

function findNearest(x,y,arr){
  let best=null, bestD=Infinity;
  for(let m of arr){
    if(m.hp<=0) continue;
    const d=dist({x,y},m);
    if(d<bestD){bestD=d;best=m;}
  }
  return best;
}

function spawnProjectile(x,y,angle,dmg,range,color,friendly,r,pierce,aoeRadius,element){
  const p={x,y,angle,dmg,range,color,friendly,r:r||5,pierce:pierce||false,
    vx:Math.cos(angle)*6, vy:Math.sin(angle)*6, dist:0, maxDist:range,
    aoeRadius:aoeRadius||0,element:element||null};
  projectiles.push(p);
  return p;
}

function dealDamage(m,dmg,element){
  if(m.hp<=0) return;
  
  // Crit
  let crit=false;
  if(Math.random()<(player.critChance||0.05)){
    dmg*=2;crit=true;
  }
  
  // Execute passive (weakness)
  if(hasPassive('execute30') && m.hp/m.maxHp<0.3) dmg*=1.5;
  
  // Burn damage passive
  if(hasPassive('burnDmg') && m.burning>0) dmg*=1.3;
  
  // Berserker passive
  if(hasPassive('berserker')){
    const hpRatio=player.hp/player.maxHp;
    dmg*=(1+(1-hpRatio)*0.5);
  }
  
  m.hp-=dmg;
  addDmgNumber(m.x,m.y-m.r,dmg,crit?'#ff0':'#ffeb3b',crit);
  
  // Apply element effects
  if(element==='fire'){m.burning=3;m.burnDmg=dmg*0.1;}
  if(element==='ice'){m.frozen=Math.max(m.frozen,1);}
  
  // Ice arrow passive
  if(hasPassive('iceArrow') && m.frozen>0){
    spawnProjectile(player.x,player.y-30,ang(player,m),player.atk*0.5,300,'#4fc3f7',true,4);
  }
  
  // Lifesteal
  if(hasPassive('lifesteal')){
    player.hp=Math.min(player.maxHp,player.hp+dmg*0.2);
  }
  
  if(m.hp<=0) onMonsterKill(m);
}

function onMonsterKill(m){
  killCount++;
  totalKills++;
  player.kills++;
  
  // EXP
  let exp = m.type==='boss'?50:m.type==='ranged'?15:10;
  exp*=(player.expMul||1);
  player.exp+=exp;
  
  // Drops
  if(Math.random()<0.3*player.luck) drops.push({x:m.x,y:m.y,type:'gold',value:rndInt(5,15+currentFloor*5)});
  if(Math.random()<0.1*player.luck) drops.push({x:m.x,y:m.y,type:'potion',value:30});
  if(Math.random()<0.05*player.luck && m.type==='boss') drops.push({x:m.x,y:m.y,type:'weapon',value:rndInt(3,8)});
  if(Math.random()<0.05*player.luck && m.type==='boss') drops.push({x:m.x,y:m.y,type:'armor',value:rndInt(2,5)});
  
  // Chain explosion passive
  if(hasPassive('chainExplosion') && Math.random()<0.3){
    addEffect('explosion',m.x,m.y,0,0,60,'#ff5722',0.3);
    for(let mm of monsters){
      if(mm!==m && mm.hp>0 && dist(m,mm)<60) dealDamage(mm,player.atk*1.5,'fire');
    }
  }
  
  // Particles
  for(let i=0;i<8;i++){
    particles.push({x:m.x,y:m.y,vx:rnd(-3,3),vy:rnd(-3,3),life:0.5,color:m.color,r:rnd(2,5)});
  }
  
  // Check level up
  while(player.exp>=player.expToLevel){
    player.exp-=player.expToLevel;
    player.level++;
    player.maxHp+=20;player.hp=Math.min(player.maxHp,player.hp+20);
    player.atk+=3;player.def+=2;
    player.expToLevel=100+player.level*20;
    // Show level up choices
    levelUpChoices=[];
    const shuffled=[...COMMON_PASSIVES].sort(()=>Math.random()-0.5);
    for(let i=0;i<3;i++) levelUpChoices.push(shuffled[i]);
    state='levelup';
  }
  
  // Check floor clear
  if(!bossSpawned && killCount>=monstersToKill){
    bossSpawned=true;
    spawnMonster('boss',MAP_W/2+rnd(-200,200),MAP_H/2+rnd(-200,200));
  }
}

// ============================================================
// EFFECTS
// ============================================================
function addEffect(type,x,y,tx,ty,r,color,duration,dmg,element,count){
  skillEffects.push({type,x,y,tx,ty,r,color,duration,maxDur:duration,dmg:dmg||0,
    element,count:count||0,time:0,triggered:false});
}

function addDmgNumber(x,y,dmg,color,crit){
  damageNumbers.push({x,y,text:Math.round(dmg)+'',color,life:1,vy:-2,size:crit?18:14});
}

function shakeScreen(intensity){
  screenShake.t=0.2;
  screenShake.intensity=intensity;
}

// ============================================================
// UPDATE
// ============================================================
function update(time){
  if(!lastTime)lastTime=time;
  dt=Math.min((time-lastTime)/1000,0.05);
  lastTime=time;
  
  if(state==='game') updateGame(dt);
  
  draw();
  requestAnimationFrame(update);
}

function updateGame(dt){
  gameTime+=dt;
  
  // Player movement
  let mx=0,my=0;
  if(keys['KeyW']||keys['ArrowUp'])my=-1;
  if(keys['KeyS']||keys['ArrowDown'])my=1;
  if(keys['KeyA']||keys['ArrowLeft'])mx=-1;
  if(keys['KeyD']||keys['ArrowRight'])mx=1;
  if(joystick.active){mx=joystick.dx;my=joystick.dy;}
  
  const len=Math.hypot(mx,my);
  if(len>0){
    mx/=len;my/=len;
    const spd=player.spd*(1+(player.spdBuff||0))*60;
    player.x=clamp(player.x+mx*spd*dt,20,MAP_W-20);
    player.y=clamp(player.y+my*spd*dt,20,MAP_H-20);
    player.facingAngle=Math.atan2(my,mx);
    
    // Blaze trail
    if(player.blaze){
      if(Math.random()<0.3){
        addEffect('zone',player.x+rnd(-10,10),player.y+rnd(-10,10),0,0,20,'#ff9800',2,player.atk*0.5,'fire');
      }
    }
  }
  
  // Timers
  if(player.atkBuffTimer>0){player.atkBuffTimer-=dt;if(player.atkBuffTimer<=0)player.atkBuff=0;}
  if(player.spdBuffTimer>0){player.spdBuffTimer-=dt;if(player.spdBuffTimer<=0)player.spdBuff=0;}
  if(player.blazeTimer>0){player.blazeTimer-=dt;if(player.blazeTimer<=0)player.blaze=false;}
  if(player.invincible>0)player.invincible-=dt;
  if(player.shieldTimer>0)player.shieldTimer-=dt;
  if(player.regen>0)player.hp=Math.min(player.maxHp,player.hp+player.regen*dt);
  
  // Skill cooldowns & auto-cast
  for(let i=0;i<3;i++){
    if(player.skillCooldowns[i]>0){
      player.skillCooldowns[i]-=dt*(1+(player.spdBuff||0));
    }
    if(autoMode && player.skillCooldowns[i]<=0 && monsters.some(m=>m.hp>0)){
      useSkill(i);
    }
  }
  
  // Update monsters
  for(let m of monsters){
    if(m.hp<=0) continue;
    
    // Status effects
    if(m.frozen>0){m.frozen-=dt;continue;}
    if(m.stunned>0){m.stunned-=dt;continue;}
    if(m.burning>0){m.burning-=dt;m.hp-=m.burnDmg*dt;if(m.hp<=0)onMonsterKill(m);}
    if(m.knockback>0){m.knockback-=dt;m.x+=m.kbx;m.y+=m.kby;continue;}
    
    const d=dist(m,player);
    
    if(d<m.aggroRange){
      // Move toward player
      const a=ang(m,player);
      if(d>m.attackRange){
        m.x+=Math.cos(a)*m.spd;
        m.y+=Math.sin(a)*m.spd;
      }
      
      // Attack
      if(m.attackCd>0){m.attackCd-=dt;continue;}
      
      if(m.type==='melee' && d<m.attackRange+player.r){
        playerTakeDamage(m.atk);
        m.attackCd=1;
      }
      if(m.type==='ranged' && d<m.attackRange){
        spawnProjectile(m.x,m.y,a,m.atk,250,'#e040fb',false,4);
        m.attackCd=2;
      }
      if(m.type==='boss'){
        if(d<m.attackRange+player.r){
          playerTakeDamage(m.atk);
          m.attackCd=1.5;
        }
        // Boss patterns
        m.patternCd=(m.patternCd||0)-dt;
        if(m.patternCd<=0){
          m.patternCd=4;
          // AoE attack
          const count=8;
          for(let i=0;i<count;i++){
            spawnProjectile(m.x,m.y,TAU*i/count,m.atk*0.7,300,'#ff9800',false,6);
          }
          addEffect('nova',m.x,m.y,0,0,80,'#ff9800',0.3);
        }
      }
    }
    
    m.x=clamp(m.x,10,MAP_W-10);
    m.y=clamp(m.y,10,MAP_H-10);
  }
  
  // Check boss defeated
  if(bossSpawned && !bossDefeated){
    const boss=monsters.find(m=>m.type==='boss');
    if(!boss || boss.hp<=0){
      bossDefeated=true;
      // Boss drops
      drops.push({x:boss?boss.x:MAP_W/2,y:boss?boss.y:MAP_H/2,type:'gold',value:rndInt(50,100+currentFloor*30)});
      if(Math.random()<0.5) drops.push({x:(boss?boss.x:MAP_W/2)+20,y:boss?boss.y:MAP_H/2,type:'weapon',value:rndInt(5,10+currentFloor*2)});
      if(Math.random()<0.5) drops.push({x:(boss?boss.x:MAP_W/2)-20,y:boss?boss.y:MAP_H/2,type:'armor',value:rndInt(3,6+currentFloor)});
      state='floorclear';
    }
  }
  
  // Update projectiles
  for(let i=projectiles.length-1;i>=0;i--){
    const p=projectiles[i];
    p.x+=p.vx;p.y+=p.vy;p.dist+=Math.hypot(p.vx,p.vy);
    
    if(p.dist>p.maxDist||p.x<0||p.x>MAP_W||p.y<0||p.y>MAP_H){
      projectiles.splice(i,1);continue;
    }
    
    if(p.friendly){
      for(let m of monsters){
        if(m.hp<=0) continue;
        if(dist(p,m)<m.r+p.r){
          if(p.aoeRadius>0){
            addEffect('explosion',p.x,p.y,0,0,p.aoeRadius,p.color,0.3);
            for(let mm of monsters){
              if(mm.hp>0 && dist(p,mm)<p.aoeRadius) dealDamage(mm,p.dmg,p.element);
            }
          } else {
            dealDamage(m,p.dmg,p.element);
          }
          if(!p.pierce){projectiles.splice(i,1);break;}
        }
      }
    } else {
      if(dist(p,player)<player.r+p.r){
        playerTakeDamage(p.dmg);
        projectiles.splice(i,1);
      }
    }
  }
  
  // Update effects
  for(let i=skillEffects.length-1;i>=0;i--){
    const e=skillEffects[i];
    e.time+=dt;
    
    // Follow player for certain effects
    if(e.type==='shield'||e.type==='orbit'){e.x=player.x;e.y=player.y;}
    
    // Gravity pull
    if(e.type==='gravity'){
      for(let m of monsters){
        if(m.hp<=0) continue;
        const d=dist(e,m);
        if(d<e.r&&d>5){
          const a=ang(m,e);
          m.x+=Math.cos(a)*3;m.y+=Math.sin(a)*3;
          if(e.time>0.5&&Math.random()<0.1) dealDamage(m,e.dmg*0.1);
        }
      }
    }
    
    // Zone damage
    if(e.type==='zone'){
      if(e.time%0.5<dt){
        for(let m of monsters){
          if(m.hp>0&&dist(e,m)<e.r) dealDamage(m,e.dmg*0.3,e.element);
        }
      }
    }
    
    // Orbit damage
    if(e.type==='orbit'){
      const count=e.count||4;
      for(let j=0;j<count;j++){
        const oa=TAU*j/count+e.time*3;
        const ox=e.x+Math.cos(oa)*e.r;
        const oy=e.y+Math.sin(oa)*e.r;
        for(let m of monsters){
          if(m.hp>0&&dist({x:ox,y:oy},m)<20) dealDamage(m,e.dmg*dt*2);
        }
      }
    }
    
    // Drone
    if(e.type==='drone'){
      e.x=player.x+Math.cos(e.time*2)*40;
      e.y=player.y-40+Math.sin(e.time*3)*10;
      if(e.time%0.4<dt){
        const near=findNearest(e.x,e.y,monsters.filter(m=>m.hp>0));
        if(near) spawnProjectile(e.x,e.y,ang(e,near),e.dmg,200,'#80deea',true,4);
      }
    }
    
    // Blade copy
    if(e.type==='bladecopy'){
      e.x=player.x+Math.cos(e.time*2)*30;
      e.y=player.y+Math.sin(e.time*2)*30;
      if(e.time%0.6<dt){
        const near=findNearest(e.x,e.y,monsters.filter(m=>m.hp>0));
        if(near&&dist(e,near)<100) dealDamage(near,e.dmg);
      }
    }
    
    // Grenade
    if(e.type==='grenade'&&!e.triggered&&e.time>=e.maxDur*0.7){
      e.triggered=true;
      // Lerp position
      const progress=1;
      const fx=lerp(e.x,e.tx,progress);
      const fy=lerp(e.y,e.ty,progress);
      addEffect('explosion',fx,fy,0,0,e.r,e.color,0.4);
      for(let m of monsters){
        if(m.hp>0&&dist({x:fx,y:fy},m)<e.r) dealDamage(m,e.dmg,e.element);
      }
      shakeScreen(6);
    }
    
    // Meteor
    if(e.type==='meteor'&&!e.triggered&&e.time>=e.maxDur){
      e.triggered=true;
      addEffect('explosion',e.x,e.y,0,0,e.r,'#ff3d00',0.5);
      for(let m of monsters){
        if(m.hp>0&&dist(e,m)<e.r) dealDamage(m,e.dmg,e.element);
      }
      shakeScreen(15);
    }
    
    if(e.time>=e.maxDur+(e.type==='meteor'?0.5:0)+(e.type==='grenade'?0.5:0)){
      skillEffects.splice(i,1);
    }
  }
  
  // Pickup drops
  for(let i=drops.length-1;i>=0;i--){
    const d=drops[i];
    const dd=dist(d,player);
    if(dd<(player.pickupRange||60)){
      // Pull toward player
      const a=ang(d,player);
      d.x+=Math.cos(a)*5;d.y+=Math.sin(a)*5;
    }
    if(dd<20){
      switch(d.type){
        case 'gold': player.gold+=d.value;break;
        case 'potion': player.hp=Math.min(player.maxHp,player.hp+d.value);
          addDmgNumber(player.x,player.y-20,'+'+d.value,'#4caf50',false);break;
        case 'weapon': player.atk+=d.value;
          addDmgNumber(player.x,player.y-20,'ATK+'+d.value,'#ff9800',false);break;
        case 'armor': player.def+=d.value;
          addDmgNumber(player.x,player.y-20,'DEF+'+d.value,'#42a5f5',false);break;
      }
      drops.splice(i,1);
    }
  }
  
  // Particles
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x+=p.vx;p.y+=p.vy;p.life-=dt;
    if(p.life<=0) particles.splice(i,1);
  }
  
  // Damage numbers
  for(let i=damageNumbers.length-1;i>=0;i--){
    const d=damageNumbers[i];
    d.y+=d.vy;d.life-=dt;
    if(d.life<=0) damageNumbers.splice(i,1);
  }
  
  // Screen shake
  if(screenShake.t>0){
    screenShake.t-=dt;
    screenShake.x=rnd(-1,1)*screenShake.intensity;
    screenShake.y=rnd(-1,1)*screenShake.intensity;
  } else {screenShake.x=0;screenShake.y=0;}
  
  // Camera
  camera.x=player.x-W/2;
  camera.y=player.y-H/2;
  
  // Remove dead monsters
  monsters=monsters.filter(m=>m.hp>0||m.type==='boss');
  
  // Check game over
  if(player.hp<=0){
    state='gameover';
  }
}

function playerTakeDamage(rawDmg){
  if(player.invincible>0) return;
  
  // Iron wall passive
  if(hasPassive('ironWall')){
    player.hitsTaken=(player.hitsTaken||0)+1;
    if(player.hitsTaken>=10){
      player.hitsTaken=0;
      addDmgNumber(player.x,player.y-30,'Ï∞®Îã®!','#90a4ae',true);
      return;
    }
  }
  
  let dmg=Math.max(1,rawDmg-player.def);
  
  // Low HP defense passive
  if(hasPassive('lowDefUp')&&player.hp/player.maxHp<0.2) dmg=Math.max(1,rawDmg-player.def*1.5);
  
  player.hp-=dmg;
  addDmgNumber(player.x,player.y-player.r,dmg,'#f44336',false);
  
  // Thorns
  if(hasPassive('thorns')){
    const nearest=findNearest(player.x,player.y,monsters.filter(m=>m.hp>0));
    if(nearest&&dist(player,nearest)<100) dealDamage(nearest,rawDmg);
  }
  
  shakeScreen(3);
}

// ============================================================
// DRAW
// ============================================================
function draw(){
  ctx.clearRect(0,0,W,H);
  
  switch(state){
    case 'title': drawTitle();break;
    case 'classSelect': drawClassSelect();break;
    case 'loadout': drawLoadout();break;
    case 'game': drawGame();break;
    case 'levelup': drawGame();drawLevelUp();break;
    case 'floorclear': drawGame();drawFloorClear();break;
    case 'victory': drawVictory();break;
    case 'gameover': drawGameOver();break;
  }
}

function drawTitle(){
  // Background
  const grd=ctx.createLinearGradient(0,0,0,H);
  grd.addColorStop(0,'#0a0a1a');grd.addColorStop(1,'#1a0a2e');
  ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);
  
  // Particles
  const t=Date.now()/1000;
  for(let i=0;i<50;i++){
    const x=(Math.sin(t*0.3+i*0.7)*0.5+0.5)*W;
    const y=(Math.cos(t*0.2+i*1.1)*0.5+0.5)*H;
    ctx.fillStyle=`rgba(150,100,255,${0.1+Math.sin(t+i)*0.1})`;
    ctx.beginPath();ctx.arc(x,y,2,0,TAU);ctx.fill();
  }
  
  // Title
  ctx.textAlign='center';
  ctx.fillStyle='#fff';
  ctx.font='bold 64px sans-serif';
  ctx.shadowColor='#7c4dff';ctx.shadowBlur=30;
  ctx.fillText('SYMMETRY',W/2,H/2-40);
  ctx.shadowBlur=0;
  
  ctx.font='18px sans-serif';
  ctx.fillStyle='#aaa';
  ctx.fillText('Î±ÄÌååÏù¥Ïñ¥ ÏÑúÎ∞îÏù¥Î≤å Ïä§ÌÉÄÏùº ARPG',W/2,H/2+10);
  
  ctx.font='16px sans-serif';
  ctx.fillStyle='#888';
  const blink=Math.sin(t*3)>0;
  if(blink) ctx.fillText('ÌÑ∞ÏπòÌïòÍ±∞ÎÇò ÌÅ¥Î¶≠ÌïòÏó¨ ÏãúÏûë',W/2,H/2+60);
}

function drawClassSelect(){
  ctx.fillStyle='#0a0a1a';ctx.fillRect(0,0,W,H);
  
  ctx.textAlign='center';
  ctx.fillStyle='#fff';ctx.font='bold 32px sans-serif';
  ctx.fillText('ÏßÅÏóÖ ÏÑ†ÌÉù',W/2,60);
  
  const cls=['gunner','mage','warrior'];
  const cw=200,ch=260,gap=30;
  const totalW=cls.length*cw+(cls.length-1)*gap;
  const startX=W/2-totalW/2;
  
  for(let i=0;i<3;i++){
    const c=CLASSES[cls[i]];
    const bx=startX+i*(cw+gap), by=H/2-ch/2+20;
    
    // Card
    ctx.fillStyle='#1a1a3e';
    ctx.strokeStyle=c.color;ctx.lineWidth=2;
    roundRect(bx,by,cw,ch,10);
    ctx.fill();ctx.stroke();
    
    // Icon
    ctx.font='48px sans-serif';ctx.textAlign='center';
    ctx.fillText(c.icon,bx+cw/2,by+60);
    
    // Name
    ctx.fillStyle=c.color;ctx.font='bold 22px sans-serif';
    ctx.fillText(c.name,bx+cw/2,by+100);
    
    ctx.fillStyle='#aaa';ctx.font='12px sans-serif';
    ctx.fillText(c.nameEn,bx+cw/2,by+120);
    
    // Desc
    ctx.fillStyle='#999';ctx.font='13px sans-serif';
    wrapText(c.desc,bx+10,by+145,cw-20,16);
    
    // Stats
    ctx.fillStyle='#666';ctx.font='11px sans-serif';
    ctx.textAlign='left';
    ctx.fillText(`HP:${c.baseHP} ATK:${c.baseATK} DEF:${c.baseDEF}`,bx+15,by+ch-20);
    ctx.textAlign='center';
  }
}

function drawLoadout(){
  ctx.fillStyle='#0a0a1a';ctx.fillRect(0,0,W,H);
  
  ctx.textAlign='center';ctx.fillStyle='#fff';ctx.font='bold 28px sans-serif';
  ctx.fillText(`${classData.name} ‚Äî Ïä§ÌÇ¨ Ïû•Ï∞©`,W/2,40);
  ctx.fillStyle='#aaa';ctx.font='14px sans-serif';
  ctx.fillText('Ïä§ÌÇ¨ 3Í∞ú + Ìå®ÏãúÎ∏å 2Í∞úÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî',W/2,65);
  
  // Skills (left)
  ctx.textAlign='left';
  ctx.fillStyle=classData.color;ctx.font='bold 16px sans-serif';
  ctx.fillText('Ïä§ÌÇ¨ (3Í∞ú ÏÑ†ÌÉù)',40,100);
  
  const sx=40, sy=120, sw=Math.min(250,W/2-60), sh=50, sg=6;
  for(let i=0;i<10;i++){
    const s=classData.skills[i];
    const bx=sx, by=sy+i*(sh+sg);
    const equipped=equippedSkills.includes(i);
    
    ctx.fillStyle=equipped?'#2a2a5e':'#151530';
    ctx.strokeStyle=equipped?classData.color:'#333';ctx.lineWidth=equipped?2:1;
    roundRect(bx,by,sw,sh,6);ctx.fill();ctx.stroke();
    
    // Color dot
    ctx.fillStyle=s.color;
    ctx.beginPath();ctx.arc(bx+15,by+sh/2,6,0,TAU);ctx.fill();
    
    ctx.fillStyle=equipped?'#fff':'#aaa';ctx.font='bold 13px sans-serif';
    ctx.fillText(s.name,bx+30,by+20);
    ctx.fillStyle='#777';ctx.font='11px sans-serif';
    ctx.fillText(s.desc.substring(0,20),bx+30,by+38);
    
    if(equipped){
      ctx.fillStyle=classData.color;ctx.font='bold 12px sans-serif';
      ctx.fillText('‚úì',bx+sw-20,by+sh/2+4);
    }
  }
  
  // Passives (right)
  const px=W/2+40, py=120, pw=Math.min(250,W/2-60), ph=50, pg=6;
  ctx.fillStyle=classData.color;ctx.font='bold 16px sans-serif';
  ctx.fillText('Ìå®ÏãúÎ∏å (2Í∞ú ÏÑ†ÌÉù)',px,100);
  
  for(let i=0;i<6;i++){
    const p=classData.passives[i];
    const bx=px, by=py+i*(ph+pg);
    const equipped=equippedPassives.includes(i);
    
    ctx.fillStyle=equipped?'#2a2a5e':'#151530';
    ctx.strokeStyle=equipped?'#ffd54f':'#333';ctx.lineWidth=equipped?2:1;
    roundRect(bx,by,pw,ph,6);ctx.fill();ctx.stroke();
    
    ctx.fillStyle=equipped?'#fff':'#aaa';ctx.font='bold 13px sans-serif';
    ctx.fillText(p.name,bx+12,by+20);
    ctx.fillStyle='#777';ctx.font='11px sans-serif';
    ctx.fillText(p.desc.substring(0,25),bx+12,by+38);
    
    if(equipped){
      ctx.fillStyle='#ffd54f';ctx.font='bold 12px sans-serif';
      ctx.fillText('‚úì',bx+pw-20,by+ph/2+4);
    }
  }
  
  // Start button
  const canStart=equippedSkills.length===3&&equippedPassives.length===2;
  const sbx=W/2-80, sby=H-80, sbw=160, sbh=50;
  ctx.fillStyle=canStart?'#4caf50':'#333';
  roundRect(sbx,sby,sbw,sbh,10);ctx.fill();
  ctx.textAlign='center';ctx.fillStyle=canStart?'#fff':'#666';ctx.font='bold 18px sans-serif';
  ctx.fillText('ÎçòÏ†Ñ ÏûÖÏû•',W/2,sby+32);
  
  ctx.fillStyle='#555';ctx.font='12px sans-serif';
  ctx.fillText(`Ïä§ÌÇ¨: ${equippedSkills.length}/3  Ìå®ÏãúÎ∏å: ${equippedPassives.length}/2`,W/2,sby-10);
}

function drawGame(){
  const cx=camera.x+screenShake.x;
  const cy=camera.y+screenShake.y;
  
  ctx.save();
  ctx.translate(-cx,-cy);
  
  // Background
  ctx.fillStyle='#0d1117';ctx.fillRect(0,0,MAP_W,MAP_H);
  
  // Grid
  ctx.strokeStyle='rgba(30,40,60,0.5)';ctx.lineWidth=1;
  const gs=64;
  const sx=Math.floor(cx/gs)*gs, sy=Math.floor(cy/gs)*gs;
  for(let x=sx;x<cx+W+gs;x+=gs){
    ctx.beginPath();ctx.moveTo(x,cy);ctx.lineTo(x,cy+H);ctx.stroke();
  }
  for(let y=sy;y<cy+H+gs;y+=gs){
    ctx.beginPath();ctx.moveTo(cx,y);ctx.lineTo(cx+W,y);ctx.stroke();
  }
  
  // Obstacles
  ctx.fillStyle='#1a2040';
  for(let o of obstacles){ctx.fillRect(o.x-o.w/2,o.y-o.h/2,o.w,o.h);}
  
  // Map border
  ctx.strokeStyle='#4a148c';ctx.lineWidth=3;
  ctx.strokeRect(0,0,MAP_W,MAP_H);
  
  // Drops
  for(let d of drops){
    let color,icon;
    switch(d.type){
      case 'gold':color='#ffd54f';icon='‚óè';break;
      case 'potion':color='#4caf50';icon='‚ô•';break;
      case 'weapon':color='#ff9800';icon='‚öî';break;
      case 'armor':color='#42a5f5';icon='üõ°';break;
    }
    ctx.fillStyle=color;ctx.font='16px sans-serif';ctx.textAlign='center';
    ctx.fillText(icon,d.x,d.y+5);
    // Glow
    ctx.beginPath();ctx.arc(d.x,d.y,8,0,TAU);
    ctx.fillStyle=color+'33';ctx.fill();
  }
  
  // Skill effects
  for(let e of skillEffects){
    const progress=e.time/e.maxDur;
    const alpha=1-progress;
    
    ctx.globalAlpha=Math.max(0,alpha);
    switch(e.type){
      case 'nova':
        ctx.strokeStyle=e.color;ctx.lineWidth=3;
        ctx.beginPath();ctx.arc(e.x,e.y,e.r*progress*1.5,0,TAU);ctx.stroke();
        ctx.fillStyle=e.color+'33';ctx.fill();
        break;
      case 'explosion':
        const er=e.r*(0.5+progress);
        ctx.fillStyle=e.color+'88';
        ctx.beginPath();ctx.arc(e.x,e.y,er,0,TAU);ctx.fill();
        ctx.strokeStyle=e.color;ctx.lineWidth=2;ctx.stroke();
        break;
      case 'cone': {
        ctx.fillStyle=e.color+'44';
        ctx.beginPath();ctx.moveTo(e.x,e.y);
        ctx.arc(e.x,e.y,e.r*(0.5+progress),e.tx-e.ty,e.tx+e.ty);
        ctx.closePath();ctx.fill();
        break;
      }
      case 'beam':
        ctx.strokeStyle=e.color;ctx.lineWidth=4+Math.sin(e.time*20)*2;
        ctx.beginPath();ctx.moveTo(e.x,e.y);ctx.lineTo(e.tx,e.ty);ctx.stroke();
        break;
      case 'wave': {
        ctx.strokeStyle=e.color;ctx.lineWidth=3;
        const wr=e.r*progress;
        ctx.beginPath();
        ctx.arc(e.x+Math.cos(e.tx)*wr*0.5,e.y+Math.sin(e.tx)*wr*0.5,wr*0.3,e.tx-1,e.tx+1);
        ctx.stroke();
        break;
      }
      case 'lightning':
        ctx.strokeStyle=e.color;ctx.lineWidth=2;
        ctx.beginPath();ctx.moveTo(e.x,e.y);
        // Jagged line
        const segs=5;
        for(let s=1;s<=segs;s++){
          const t=s/segs;
          const lx=lerp(e.x,e.tx,t)+rnd(-10,10);
          const ly=lerp(e.y,e.ty,t)+rnd(-10,10);
          ctx.lineTo(lx,ly);
        }
        ctx.stroke();
        break;
      case 'zone':
        ctx.fillStyle=e.color+'22';
        ctx.beginPath();ctx.arc(e.x,e.y,e.r,0,TAU);ctx.fill();
        ctx.strokeStyle=e.color+'66';ctx.lineWidth=1;ctx.stroke();
        // Flame particles
        if(Math.random()<0.3){
          particles.push({x:e.x+rnd(-e.r,e.r),y:e.y+rnd(-e.r,e.r),vx:rnd(-1,1),vy:-rnd(1,3),life:0.5,color:e.color,r:rnd(1,3)});
        }
        break;
      case 'gravity':
        ctx.strokeStyle=e.color;ctx.lineWidth=2;
        for(let ring=0;ring<3;ring++){
          ctx.beginPath();ctx.arc(e.x,e.y,e.r*(1-ring*0.25)*(1-progress*0.3),0,TAU);ctx.stroke();
        }
        break;
      case 'shield':
        ctx.strokeStyle='#80deea';ctx.lineWidth=3;
        ctx.beginPath();ctx.arc(e.x,e.y,22+Math.sin(e.time*5)*3,0,TAU);ctx.stroke();
        ctx.fillStyle='#80deea22';ctx.fill();
        break;
      case 'meteor':
        if(!e.triggered){
          // Warning circle
          ctx.strokeStyle='#ff3d0088';ctx.lineWidth=2;ctx.setLineDash([5,5]);
          ctx.beginPath();ctx.arc(e.x,e.y,e.r,0,TAU);ctx.stroke();ctx.setLineDash([]);
          // Growing inner circle
          ctx.fillStyle=`rgba(255,60,0,${progress*0.3})`;
          ctx.beginPath();ctx.arc(e.x,e.y,e.r*progress,0,TAU);ctx.fill();
        }
        break;
      case 'snipeline':
        ctx.strokeStyle='#ff1744';ctx.lineWidth=2;
        ctx.beginPath();ctx.moveTo(e.x,e.y);ctx.lineTo(e.tx,e.ty);ctx.stroke();
        break;
      case 'charge':
        ctx.strokeStyle=e.color+'88';ctx.lineWidth=e.r;
        ctx.beginPath();ctx.moveTo(e.x,e.y);ctx.lineTo(e.tx,e.ty);ctx.stroke();
        break;
      case 'crack':
        ctx.strokeStyle=e.color;ctx.lineWidth=4;
        ctx.beginPath();ctx.moveTo(e.x,e.y);
        ctx.lineTo(e.x+Math.cos(e.tx)*e.r,e.y+Math.sin(e.tx)*e.r);
        ctx.stroke();
        break;
      case 'orbit': {
        const count=e.count||4;
        for(let j=0;j<count;j++){
          const oa=TAU*j/count+e.time*3;
          const ox=e.x+Math.cos(oa)*e.r;
          const oy=e.y+Math.sin(oa)*e.r;
          ctx.fillStyle=e.color;
          ctx.beginPath();ctx.arc(ox,oy,8,0,TAU);ctx.fill();
        }
        break;
      }
      case 'drone':
        ctx.fillStyle=e.color;
        ctx.fillRect(e.x-10,e.y-5,20,10);
        ctx.fillStyle='#fff';ctx.fillRect(e.x-3,e.y+5,6,3);
        break;
      case 'bladecopy':
        ctx.fillStyle=e.color;
        ctx.save();ctx.translate(e.x,e.y);ctx.rotate(e.time*5);
        ctx.fillRect(-12,-3,24,6);ctx.restore();
        break;
      case 'buff':
        ctx.strokeStyle=e.color;ctx.lineWidth=2;
        ctx.beginPath();ctx.arc(e.x,e.y,e.r+e.time*30,0,TAU);ctx.stroke();
        break;
      case 'grenade':
        if(!e.triggered){
          const gp=Math.min(1,e.time/(e.maxDur*0.7));
          const gx=lerp(e.x,e.tx,gp);
          const gy=lerp(e.y,e.ty,gp)-Math.sin(gp*PI)*40;
          ctx.fillStyle=e.color;
          ctx.beginPath();ctx.arc(gx,gy,6,0,TAU);ctx.fill();
        }
        break;
    }
    ctx.globalAlpha=1;
  }
  
  // Monsters
  for(let m of monsters){
    if(m.hp<=0) continue;
    
    // Shadow
    ctx.fillStyle='rgba(0,0,0,0.3)';
    ctx.beginPath();ctx.ellipse(m.x,m.y+m.r,m.r,m.r*0.3,0,0,TAU);ctx.fill();
    
    // Body
    let bodyColor=m.color;
    if(m.frozen>0) bodyColor='#4fc3f7';
    if(m.burning>0) bodyColor='#ff5722';
    
    ctx.fillStyle=bodyColor;
    if(m.type==='boss'){
      // Boss - hexagon
      ctx.beginPath();
      for(let i=0;i<6;i++){const a=TAU*i/6-PI/2;ctx.lineTo(m.x+Math.cos(a)*m.r,m.y+Math.sin(a)*m.r);}
      ctx.closePath();ctx.fill();
      ctx.strokeStyle='#fff3';ctx.lineWidth=2;ctx.stroke();
    } else {
      ctx.beginPath();ctx.arc(m.x,m.y,m.r,0,TAU);ctx.fill();
    }
    
    // Eyes
    ctx.fillStyle='#fff';
    const ea=ang(m,player);
    ctx.beginPath();ctx.arc(m.x+Math.cos(ea)*m.r*0.3-4,m.y+Math.sin(ea)*m.r*0.3-2,3,0,TAU);ctx.fill();
    ctx.beginPath();ctx.arc(m.x+Math.cos(ea)*m.r*0.3+4,m.y+Math.sin(ea)*m.r*0.3-2,3,0,TAU);ctx.fill();
    
    // HP bar
    if(m.hp<m.maxHp){
      const bw=m.r*2, bh=4;
      ctx.fillStyle='#333';ctx.fillRect(m.x-bw/2,m.y-m.r-10,bw,bh);
      ctx.fillStyle=m.type==='boss'?'#ff9800':'#f44336';
      ctx.fillRect(m.x-bw/2,m.y-m.r-10,bw*(m.hp/m.maxHp),bh);
    }
    
    // Stun indicator
    if(m.stunned>0){
      ctx.fillStyle='#ffd54f';ctx.font='12px sans-serif';ctx.textAlign='center';
      ctx.fillText('üí´',m.x,m.y-m.r-15);
    }
    if(m.frozen>0){
      ctx.fillStyle='#4fc3f7';ctx.font='10px sans-serif';ctx.textAlign='center';
      ctx.fillText('‚ùÑ',m.x,m.y-m.r-15);
    }
  }
  
  // Player
  if(player){
    const px=player.x, py=player.y;
    
    // Shadow
    ctx.fillStyle='rgba(0,0,0,0.3)';
    ctx.beginPath();ctx.ellipse(px,py+player.r,player.r,player.r*0.3,0,0,TAU);ctx.fill();
    
    // Invincibility glow
    if(player.invincible>0){
      ctx.fillStyle='rgba(128,222,234,0.2)';
      ctx.beginPath();ctx.arc(px,py,player.r+8+Math.sin(gameTime*8)*3,0,TAU);ctx.fill();
    }
    
    // Body
    ctx.fillStyle=classData.color;
    ctx.beginPath();ctx.arc(px,py,player.r,0,TAU);ctx.fill();
    ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();
    
    // Facing indicator
    ctx.fillStyle='#fff';
    ctx.beginPath();
    ctx.arc(px+Math.cos(player.facingAngle)*player.r*0.6,
            py+Math.sin(player.facingAngle)*player.r*0.6,4,0,TAU);
    ctx.fill();
    
    // Class icon
    ctx.font='14px sans-serif';ctx.textAlign='center';
    ctx.fillText(classData.icon,px,py+5);
  }
  
  // Projectiles
  for(let p of projectiles){
    ctx.fillStyle=p.color;
    ctx.beginPath();ctx.arc(p.x,p.y,p.r,0,TAU);ctx.fill();
    // Trail
    ctx.fillStyle=p.color+'44';
    ctx.beginPath();ctx.arc(p.x-p.vx,p.y-p.vy,p.r*0.7,0,TAU);ctx.fill();
  }
  
  // Particles
  for(let p of particles){
    ctx.fillStyle=p.color;
    ctx.globalAlpha=p.life*2;
    ctx.beginPath();ctx.arc(p.x,p.y,p.r,0,TAU);ctx.fill();
  }
  ctx.globalAlpha=1;
  
  // Damage numbers
  for(let d of damageNumbers){
    ctx.fillStyle=d.color;
    ctx.globalAlpha=d.life;
    ctx.font=`bold ${d.size}px sans-serif`;
    ctx.textAlign='center';
    ctx.fillText(d.text,d.x,d.y);
  }
  ctx.globalAlpha=1;
  
  ctx.restore();
  
  // ---- HUD (screen space) ----
  drawHUD();
}

function drawHUD(){
  if(!player) return;
  const pad=15;
  
  // HP bar
  const hpW=200, hpH=18;
  ctx.fillStyle='#333';roundRect(pad,pad,hpW,hpH,4);ctx.fill();
  ctx.fillStyle='#e53935';roundRect(pad,pad,hpW*(player.hp/player.maxHp),hpH,4);ctx.fill();
  ctx.fillStyle='#fff';ctx.font='bold 12px sans-serif';ctx.textAlign='left';
  ctx.fillText(`HP: ${Math.round(player.hp)}/${Math.round(player.maxHp)}`,pad+5,pad+14);
  
  // EXP bar
  ctx.fillStyle='#222';roundRect(pad,pad+hpH+4,hpW,10,3);ctx.fill();
  ctx.fillStyle='#7c4dff';roundRect(pad,pad+hpH+4,hpW*(player.exp/player.expToLevel),10,3);ctx.fill();
  
  // Level
  ctx.fillStyle='#fff';ctx.font='bold 14px sans-serif';
  ctx.fillText(`Lv.${player.level}`,pad+hpW+10,pad+14);
  
  // Floor
  ctx.fillText(`${currentFloor}Ï∏µ`,pad+hpW+10,pad+32);
  
  // Gold & Kills
  ctx.fillStyle='#ffd54f';ctx.font='13px sans-serif';
  ctx.fillText(`üí∞ ${player.gold}`,pad,pad+hpH+24);
  ctx.fillStyle='#ef5350';
  ctx.fillText(`üíÄ ${totalKills}`,pad+80,pad+hpH+24);
  
  // ATK/DEF
  ctx.fillStyle='#ff9800';ctx.font='12px sans-serif';
  ctx.fillText(`ATK:${Math.round(player.atk*(1+player.atkBuff))}`,pad+160,pad+hpH+24);
  ctx.fillStyle='#42a5f5';
  ctx.fillText(`DEF:${player.def}`,pad+230,pad+hpH+24);
  
  // Auto/Manual indicator
  ctx.fillStyle=autoMode?'#4caf50':'#ff9800';
  ctx.font='bold 14px sans-serif';
  ctx.textAlign='right';
  ctx.fillText(autoMode?'ÏûêÎèô':'ÏàòÎèô',W-pad,pad+16);
  ctx.fillStyle='#888';ctx.font='11px sans-serif';
  ctx.fillText('SPACE Ï†ÑÌôò',W-pad,pad+32);
  
  // Skill slots (bottom center)
  ctx.textAlign='center';
  const slotW=60, slotH=60, slotGap=10;
  const totalSW=3*slotW+2*slotGap;
  const slotStartX=W/2-totalSW/2;
  const slotY=H-slotH-pad-(IS_TOUCH?60:0);
  
  for(let i=0;i<3;i++){
    const sx=slotStartX+i*(slotW+slotGap);
    const skill=classData.skills[equippedSkills[i]];
    const cd=player.skillCooldowns[i];
    const maxCd=getCooldown(skill.cd);
    
    // Slot background
    ctx.fillStyle='#1a1a3e';
    roundRect(sx,slotY,slotW,slotH,8);ctx.fill();
    ctx.strokeStyle=skill.color;ctx.lineWidth=2;
    roundRect(sx,slotY,slotW,slotH,8);ctx.stroke();
    
    // Cooldown overlay
    if(cd>0){
      ctx.fillStyle='rgba(0,0,0,0.6)';
      const cdRatio=cd/maxCd;
      ctx.fillRect(sx+2,slotY+2+(1-cdRatio)*(slotH-4),slotW-4,(slotH-4)*cdRatio);
    }
    
    // Skill color dot
    ctx.fillStyle=skill.color;
    ctx.beginPath();ctx.arc(sx+slotW/2,slotY+20,8,0,TAU);ctx.fill();
    
    // Name
    ctx.fillStyle='#fff';ctx.font='bold 10px sans-serif';
    ctx.fillText(skill.name.substring(0,4),sx+slotW/2,slotY+42);
    
    // Key hint
    if(!IS_TOUCH){
      ctx.fillStyle='#666';ctx.font='9px sans-serif';
      ctx.fillText(`${i+1}`,sx+slotW/2,slotY+55);
    }
    
    // Cooldown text
    if(cd>0){
      ctx.fillStyle='#fff';ctx.font='bold 14px sans-serif';
      ctx.fillText(cd.toFixed(1),sx+slotW/2,slotY+slotH/2+5);
    }
  }
  
  // Passive icons (bottom-left)
  ctx.textAlign='left';
  for(let i=0;i<equippedPassives.length;i++){
    const p=classData.passives[equippedPassives[i]];
    const px=pad, py=slotY-10+i*(-30);
    ctx.fillStyle='#1a1a3e';roundRect(px,py-18,110,24,4);ctx.fill();
    ctx.strokeStyle='#ffd54f44';ctx.lineWidth=1;roundRect(px,py-18,110,24,4);ctx.stroke();
    ctx.fillStyle='#ffd54f';ctx.font='11px sans-serif';
    ctx.fillText('‚≠ê'+p.name.substring(0,8),px+4,py);
  }
  
  // Mini-map (top-right)
  const mmW=100, mmH=100;
  const mmX=W-mmW-pad, mmY=pad+40;
  ctx.fillStyle='rgba(10,10,30,0.7)';ctx.fillRect(mmX,mmY,mmW,mmH);
  ctx.strokeStyle='#333';ctx.lineWidth=1;ctx.strokeRect(mmX,mmY,mmW,mmH);
  
  // Player on minimap
  const pmx=mmX+(player.x/MAP_W)*mmW;
  const pmy=mmY+(player.y/MAP_H)*mmH;
  ctx.fillStyle=classData.color;
  ctx.beginPath();ctx.arc(pmx,pmy,3,0,TAU);ctx.fill();
  
  // Monsters on minimap
  for(let m of monsters){
    if(m.hp<=0) continue;
    const mx=mmX+(m.x/MAP_W)*mmW;
    const my=mmY+(m.y/MAP_H)*mmH;
    ctx.fillStyle=m.type==='boss'?'#ff9800':'#f44336';
    ctx.fillRect(mx-1,my-1,2,2);
  }
  
  // Mobile controls
  if(IS_TOUCH){
    // Joystick base
    if(joystick.active){
      ctx.strokeStyle='rgba(255,255,255,0.3)';ctx.lineWidth=2;
      ctx.beginPath();ctx.arc(joystick.sx,joystick.sy,50,0,TAU);ctx.stroke();
      ctx.fillStyle='rgba(255,255,255,0.4)';
      ctx.beginPath();ctx.arc(joystick.sx+joystick.dx*50,joystick.sy+joystick.dy*50,20,0,TAU);ctx.fill();
    }
    
    // Mobile skill buttons (right side)
    for(let i=0;i<3;i++){
      const bx=W-70, by=H-180+i*60;
      const skill=classData.skills[equippedSkills[i]];
      ctx.fillStyle='rgba(30,30,60,0.8)';
      ctx.beginPath();ctx.arc(bx,by,28,0,TAU);ctx.fill();
      ctx.strokeStyle=skill.color;ctx.lineWidth=2;
      ctx.beginPath();ctx.arc(bx,by,28,0,TAU);ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 11px sans-serif';ctx.textAlign='center';
      ctx.fillText(skill.name.substring(0,3),bx,by+4);
    }
    
    // Auto toggle button
    mobileAutoBtn.x=W-40;mobileAutoBtn.y=H-250;
    ctx.fillStyle=autoMode?'#4caf5088':'#ff980088';
    ctx.beginPath();ctx.arc(mobileAutoBtn.x,mobileAutoBtn.y,mobileAutoBtn.r,0,TAU);ctx.fill();
    ctx.fillStyle='#fff';ctx.font='bold 10px sans-serif';ctx.textAlign='center';
    ctx.fillText(autoMode?'ÏûêÎèô':'ÏàòÎèô',mobileAutoBtn.x,mobileAutoBtn.y+4);
  }
}

function drawLevelUp(){
  ctx.fillStyle='rgba(0,0,0,0.7)';ctx.fillRect(0,0,W,H);
  
  ctx.textAlign='center';ctx.fillStyle='#ffd54f';ctx.font='bold 28px sans-serif';
  ctx.fillText('‚¨Ü Î†àÎ≤® ÏóÖ!',W/2,H/2-100);
  ctx.fillStyle='#aaa';ctx.font='14px sans-serif';
  ctx.fillText('ÌïòÎÇòÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî',W/2,H/2-70);
  
  const cw=200, ch=90, gap=20;
  const totalCW=levelUpChoices.length*cw+(levelUpChoices.length-1)*gap;
  const startX=W/2-totalCW/2;
  
  for(let i=0;i<levelUpChoices.length;i++){
    const c=levelUpChoices[i];
    const bx=startX+i*(cw+gap), by=H/2-ch/2;
    
    ctx.fillStyle='#1a1a3e';ctx.strokeStyle='#7c4dff';ctx.lineWidth=2;
    roundRect(bx,by,cw,ch,8);ctx.fill();ctx.stroke();
    
    ctx.fillStyle='#fff';ctx.font='bold 15px sans-serif';
    ctx.fillText(c.name,bx+cw/2,by+30);
    ctx.fillStyle='#aaa';ctx.font='12px sans-serif';
    ctx.fillText(c.desc,bx+cw/2,by+55);
  }
}

function drawFloorClear(){
  ctx.fillStyle='rgba(0,0,0,0.6)';ctx.fillRect(0,0,W,H);
  ctx.textAlign='center';
  ctx.fillStyle='#4caf50';ctx.font='bold 36px sans-serif';
  ctx.fillText(`${currentFloor}Ï∏µ ÌÅ¥Î¶¨Ïñ¥!`,W/2,H/2-30);
  ctx.fillStyle='#aaa';ctx.font='16px sans-serif';
  ctx.fillText(currentFloor>=totalFloors?'ÌÅ¥Î¶≠ÌïòÏó¨ ÏôÑÎ£å':'ÌÅ¥Î¶≠ÌïòÏó¨ Îã§Ïùå Ï∏µÏúºÎ°ú',W/2,H/2+20);
}

function drawVictory(){
  ctx.fillStyle='#0a0a1a';ctx.fillRect(0,0,W,H);
  ctx.textAlign='center';
  ctx.fillStyle='#ffd54f';ctx.font='bold 48px sans-serif';
  ctx.shadowColor='#ffd54f';ctx.shadowBlur=20;
  ctx.fillText('üèÜ ÏäπÎ¶¨!',W/2,H/2-40);
  ctx.shadowBlur=0;
  ctx.fillStyle='#fff';ctx.font='18px sans-serif';
  ctx.fillText(`${classData.name} Lv.${player.level} ‚Äî ${totalKills}ÌÇ¨`,W/2,H/2+10);
  ctx.fillStyle='#888';ctx.font='14px sans-serif';
  ctx.fillText('ÌÅ¥Î¶≠ÌïòÏó¨ ÌÉÄÏù¥ÌãÄÎ°ú',W/2,H/2+50);
}

function drawGameOver(){
  ctx.fillStyle='#1a0000';ctx.fillRect(0,0,W,H);
  ctx.textAlign='center';
  ctx.fillStyle='#f44336';ctx.font='bold 48px sans-serif';
  ctx.fillText('üíÄ ÏÇ¨Îßù',W/2,H/2-40);
  ctx.fillStyle='#aaa';ctx.font='16px sans-serif';
  ctx.fillText(`${currentFloor}Ï∏µ ‚Äî ${totalKills}ÌÇ¨`,W/2,H/2+10);
  ctx.fillStyle='#888';ctx.font='14px sans-serif';
  ctx.fillText('ÌÅ¥Î¶≠ÌïòÏó¨ ÌÉÄÏù¥ÌãÄÎ°ú',W/2,H/2+50);
}

// ============================================================
// HELPERS
// ============================================================
function roundRect(x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);ctx.lineTo(x+w-r,y);ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r);ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h);ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r);ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.closePath();
}

function wrapText(text,x,y,maxW,lineH){
  const chars=text.split('');
  let line='';
  let ly=y;
  for(let c of chars){
    const test=line+c;
    if(ctx.measureText(test).width>maxW&&line){
      ctx.fillText(line,x,ly);ly+=lineH;line=c;
    } else line=test;
  }
  if(line) ctx.fillText(line,x,ly);
}

// Manual skill keys (1,2,3)
addEventListener('keydown',e=>{
  if(state==='game'&&!autoMode){
    if(e.code==='Digit1') useSkill(0);
    if(e.code==='Digit2') useSkill(1);
    if(e.code==='Digit3') useSkill(2);
  }
});

// ============================================================
// START
// ============================================================
requestAnimationFrame(update);
</script>
</body>
</html>
